// Copyright (c) 2022, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:http/http.dart';


void hybridMain() async {
  final server = await HttpServer.bind('localhost', 8080);
  print("Server listening on port ${server.port}");
  final url = Uri.http('localhost:${server.port}', '');

  server.defaultResponseHeaders.set('Access-Control-Allow-Origin', '*');
  server.defaultResponseHeaders.set('Access-Control-Allow-Methods', 'POST, GET, OPTIONS');
  server.defaultResponseHeaders.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  server.defaultResponseHeaders.set('Access-Control-Allow-Credentials', 'true');

  server.listen((request) async {
    var path = request.uri.path;
    var response = request.response;

    if (path == '/ping') {
      response
        ..statusCode = 200
        ..contentLength = 0;
      unawaited(response.close());
      return;
    }



    if (path == '/multipart') {
      var completer = Completer<void>();
      var length = 0;
      request.listen((event) {
        length += event.length;
      }).onDone(completer.complete);
      await completer.future;
      print("res $length");
      response
        ..statusCode = 200
        ..contentLength = length.toString().codeUnits.length
        ..write(length.toString());
      unawaited(response.close());
      return;
    }

    if (path == '/streamed') {
      var length = 0;

      /// Browser send speed is uncontrollable, so we need to slow down the
      /// server to make sure the progress event is triggered.
      await for (var event in request) {
        await Future.delayed(Duration(milliseconds: 50));
        length += event.length;
      }

      response
        ..statusCode = 200
        ..contentLength = length.toString().codeUnits.length
        ..write(length.toString());
      unawaited(response.close());
      return;
    }

    if (path == '/download') {
      response
        ..statusCode = 200
        ..contentLength = -1;

      _generateStream(20).listen((event) {
        response.add(event);
      }, onDone: () {
        unawaited(response.close());
      });

      return;
    }

    var requestBodyBytes = await ByteStream(request).toBytes();
    var encodingName = request.uri.queryParameters['response-encoding'];
    var outputEncoding =
    encodingName == null ? ascii : requiredEncodingForCharset(encodingName);

    response.headers.contentType =
        ContentType('application', 'json', charset: outputEncoding.name);
    response.headers.set('single', 'value');

    dynamic requestBody;
    if (requestBodyBytes.isEmpty) {
      requestBody = null;
    } else if (request.headers.contentType?.charset != null) {
      var encoding =
      requiredEncodingForCharset(request.headers.contentType!.charset!);
      requestBody = encoding.decode(requestBodyBytes);
    } else {
      requestBody = requestBodyBytes;
    }

    final headers = <String, List<String>>{};

    request.headers.forEach((name, values) {
      // These headers are automatically generated by dart:io, so we don't
      // want to test them here.
      if (name == 'cookie' || name == 'host') return;

      headers[name] = values;
    });

    var content = <String, dynamic>{
      'method': request.method,
      'path': request.uri.path,
      if (requestBody != null) 'body': requestBody,
      'headers': headers,
    };

    var body = json.encode(content);
    response
      ..contentLength = body.length
      ..write(body);
    unawaited(response.close());
  });
}

const _kb = 1 << 10;

Stream<List<int>> _generateStream(int length) async* {
  var i = 0;
  while (i < length) {
    await Future<void>.delayed(const Duration(milliseconds: 500));
    yield List.generate(_kb * 8, (index) => 0);
    i += 1;
  }

  return;
}


void main() {
  hybridMain();
}


/// Returns the [Encoding] that corresponds to [charset].
///
/// Returns [fallback] if [charset] is null or if no [Encoding] was found that
/// corresponds to [charset].
Encoding encodingForCharset(String? charset, [Encoding fallback = latin1]) {
  if (charset == null) return fallback;
  return Encoding.getByName(charset) ?? fallback;
}

/// Returns the [Encoding] that corresponds to [charset].
///
/// Throws a [FormatException] if no [Encoding] was found that corresponds to
/// [charset].
Encoding requiredEncodingForCharset(String charset) =>
    Encoding.getByName(charset) ??
        (throw FormatException('Unsupported encoding "$charset".'));
