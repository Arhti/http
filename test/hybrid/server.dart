// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:convert';
import 'dart:io';

import 'package:async/async.dart';
import 'package:http/src/utils.dart';
import "package:stream_channel/stream_channel.dart";

/// The list of headers to ignore when sending back confirmation.
final _ignoreHeaders = <String>[
  // Browser headers (Chrome)
  'accept',
  'accept-language',
  'accept-encoding',
  'connection',
  'origin',
  'referer',

  // Dart IO headers
  'cookie',
  'host',
];

/// Creates a server used to test a `http` client.
///
/// On startup the server will bind to `localhost`. Then it will send the url
/// as a string back through the [channel].
///
/// The server has the following explicit endpoints used to test individual
/// functionality.
/// * /error - Will return a 400 status code.
/// * /loop - Which is used to check for max redirects.
/// * /redirect - Which is used to test that a redirect works.
/// * /no-content-length - Which returns a body with no content.
///
/// All other requests will be responded to. This is used to test the
/// individual HTTP methods. The server will return back the following
/// information in a string.
///
///     {
///       method: 'METHOD_NAME',
///       path: 'ENDPOINT_PATH',
///       headers: {
///         KEY VALUE STORE OF INDIVIDUAL HEADERS
///       },
///       body: OPTIONAL
///     }
hybridMain(StreamChannel channel) async {
  var server = await HttpServer.bind('localhost', 0);
  var serverUrl = Uri.parse('http://localhost:${server.port}');

  server.listen((request) {
    var path = request.uri.path;
    var response = request.response;

    if (path == '/error') {
      response.statusCode = 400;
      response.contentLength = 0;
      response.close();
      return;
    }

    if (path == '/loop') {
      var n = int.parse(request.uri.query);
      response.statusCode = 302;
      response.headers
          .set('location', serverUrl.resolve('/loop?${n + 1}').toString());
      response.contentLength = 0;
      response.close();
      return;
    }

    if (path == '/redirect') {
      response.statusCode = 302;
      response.headers.set('location', serverUrl.resolve('/').toString());
      response.contentLength = 0;
      response.close();
      return;
    }

    if (path == '/no-content-length') {
      response.statusCode = 200;
      response.contentLength = -1;
      response.write('body');
      response.close();
      return;
    }

    collectBytes(request).then((requestBodyBytes) {
      var outputEncoding;
      var encodingName = request.uri.queryParameters['response-encoding'];
      if (encodingName != null) {
        outputEncoding = requiredEncodingForCharset(encodingName);
      } else {
        outputEncoding = ASCII;
      }

      response.headers.contentType =
          new ContentType("application", "json", charset: outputEncoding.name);

      // Add CORS headers for browser testing
      response.headers.set('access-control-allow-origin', '*');
      response.headers.set(
          'access-control-allow-headers', 'X-Random-Header,X-Other-Header');
      response.headers.set('access-control-allow-methods',
          'GET, PUT, POST, DELETE, PATCH, HEAD');

      var requestBody;
      if (requestBodyBytes.isEmpty) {
        requestBody = null;
      } else if (request.headers.contentType != null &&
          request.headers.contentType.charset != null) {
        var encoding =
            requiredEncodingForCharset(request.headers.contentType.charset);
        requestBody = encoding.decode(requestBodyBytes);
      } else {
        requestBody = requestBodyBytes;
      }

      var content = {
        'method': request.method,
        'path': request.uri.path,
        'headers': {}
      };
      if (requestBody != null) content['body'] = requestBody;
      request.headers.forEach((name, values) {
        // Ignore headers that are generated by the client
        if (_ignoreHeaders.contains(name)) return;

        (content['headers'] as Map)[name] = values;
      });

      var body = JSON.encode(content);
      response.contentLength = body.length;
      response.write(body);
      response.close();
    });
  });

  channel.sink.add(serverUrl.toString());
}
